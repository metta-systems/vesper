#
# SPDX-License-Identifier: BlueOak-1.0.0
#
# Copyright (c) Berkus Decker <berkus+vesper@metta.systems>
#
[config]
min_version = "0.32.0"
default_to_workspace = true

[env]
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

DEFAULT_TARGET = "aarch64-vesper-metta"

#===================
# User-configurable
#===================

#-----------------------
# Target configuration.
#-----------------------

# Target triple.
# Pass TARGET env var if it does not match the default target above.
TARGET = { value = "${DEFAULT_TARGET}", condition = { env_not_set = ["TARGET"] } }

# Name of the target board.
# Currently supported: "rpi3" or "rpi4"
TARGET_BOARD = { value = "rpi4", condition = { env_not_set = ["TARGET_BOARD"] } }

# Name of the DTB file for target board configuration.
# Use bcm2710-rpi-3-b-plus.dtb for RasPi3B+.
TARGET_DTB = { value = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2711-rpi-4-b.dtb", condition = { env_not_set = ["TARGET_DTB"] } }

#------------------------
# Tooling configuration.
# (AArch64 targets for now)
#------------------------

# AArch64 QEMU binary
QEMU = { value = "qemu-system-aarch64", condition = { env_not_set = ["QEMU"] } }
# QEMU machine type, defaults to raspi3b but CI runners override it due to ancient QEMU versions they use.
QEMU_MACHINE = { value = "raspi3b", condition = { env_not_set = ["QEMU_MACHINE"] } }

# An aarch64-enabled GDB
GDB = { value = "/usr/local/opt/gdb/HEAD-a2c58332-aarch64/bin/aarch64-unknown-elf-gdb", condition = { env_not_set = ["GDB"] } }

# OpenOCD with JLink support
# (RTT patch from http://openocd.zylin.com/#/c/4055/11 has already been merged into main line)
OPENOCD = { value = "/usr/local/opt/openocd/4d6519593-rtt/bin/openocd", condition = { env_not_set = ["OPENOCD"] } }

# Path to a mounted sdcard partition to copy binaries to.
VOLUME = { value = "/Volumes/BOOT", condition = { env_not_set = ["VOLUME"] } }

#==================================
# Automatic.
# Nothing user-configurable below.
#==================================

RUST_STD = "-Zbuild-std=compiler_builtins,core,alloc"
RUST_STD_FEATURES = "-Zbuild-std-features=compiler-builtins-mem"

# Kernel binary paths.
KERNEL_ELF = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${TARGET}/release/nucleus"
KERNEL_BIN = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/nucleus.bin"

# Chain bootloader configuration.
CHAINBOOT_SERIAL = "/dev/tty.SLAB_USBtoUART"
CHAINBOOT_BAUD = 115200

#==========
# Commands
#==========

OBJCOPY = "rust-objcopy" # Part of `cargo objcopy` in cargo-binutils
OBJCOPY_PARAMS = "--strip-all -O binary"
NM = "rust-nm" # Part of `cargo nm` in cargo-binutils

# Containerised commands
UTILS_CONTAINER = "andrerichter/raspi3-utils"
DOCKER_CMD = "docker run -it --rm -v ${PWD}:/work -w /work -p 5900:5900"
QEMU_CONTAINER_CMD = "qemu-system-aarch64"

#================================================================
# Target settings
# Build requires "release" flag to properly optimize the binary.
#================================================================

TARGET_JSON = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/${TARGET}.json"
PLATFORM_TARGET="--release --target=${TARGET_JSON} --features=${TARGET_FEATURES}"

#=================
# Target features
#=================

DEVICE_FEATURES = "noserial"
QEMU_FEATURES = "qemu,rpi3" #,noserial"

#===================
# Emulation options
#===================
#
# Could additionally use -nographic to disable GUI -- this shall be useful for automated tests.
#
# QEMU has renamed the RasPi machines since version 6.2.0, use just `raspi3` for previous versions.
QEMU_OPTS = "-M ${QEMU_MACHINE} -semihosting-config enable=on,target=native"
QEMU_DISASM_OPTS = "-d in_asm,unimp,int,mmu,cpu_reset,guest_errors"
QEMU_SERIAL_OPTS = "-monitor none -serial stdio"  #-serial pty -serial stdio"
QEMU_TESTS_OPTS = "-nographic" #-chardev file,id=char0,mux=on,path=debug.log -mon chardev=char0,mode=readline -semihosting-config chardev=char0 -D error.log"

# For -d trace:
# E.g. -d trace:arm*,bcm2835_*,gic*,memory_*,pl011_*

# Also, try -d exec,nochain,out_asm for a full runtime dump?

#134   │ arm_gt_cntvoff_write
#135   │ arm_gt_ctl_write
#136   │ arm_gt_cval_write
#137   │ arm_gt_imask_toggle
#138   │ arm_gt_recalc
#139   │ arm_gt_recalc_disabled
#140   │ arm_gt_tval_write
#141   │ armsse_cpu_pwrctrl_read
#142   │ armsse_cpu_pwrctrl_write
#143   │ armsse_cpuid_read
#144   │ armsse_cpuid_write
#145   │ armsse_mhu_read
#146   │ armsse_mhu_write

#224   │ bcm2835_cprman_read
#225   │ bcm2835_cprman_write
#226   │ bcm2835_cprman_write_invalid_magic
#227   │ bcm2835_ic_set_cpu_irq
#228   │ bcm2835_ic_set_gpu_irq
#229   │ bcm2835_mbox_irq
#230   │ bcm2835_mbox_property
#231   │ bcm2835_mbox_read
#232   │ bcm2835_mbox_write
#233   │ bcm2835_sdhost_edm_change
#234   │ bcm2835_sdhost_read
#235   │ bcm2835_sdhost_update_irq
#236   │ bcm2835_sdhost_write
#237   │ bcm2835_systmr_irq_ack
#238   │ bcm2835_systmr_read
#239   │ bcm2835_systmr_run
#240   │ bcm2835_systmr_timer_expired
#241   │ bcm2835_systmr_write

#782   │ gic_acknowledge_irq
#783   │ gic_cpu_read
#784   │ gic_cpu_write
#785   │ gic_disable_irq
#786   │ gic_dist_read
#787   │ gic_dist_write
#788   │ gic_enable_irq
#789   │ gic_hyp_read
#790   │ gic_hyp_write
#791   │ gic_lr_entry
#792   │ gic_set_irq
#793   │ gic_update_bestirq
#794   │ gic_update_maintenance_irq
#795   │ gic_update_set_irq

#796   │ gicv3_cpuif_set_irqs
#797   │ gicv3_cpuif_update
#798   │ gicv3_cpuif_virt_set_irqs
#799   │ gicv3_cpuif_virt_set_maint_irq
#800   │ gicv3_cpuif_virt_update
#801   │ gicv3_dist_badread
#802   │ gicv3_dist_badwrite
#803   │ gicv3_dist_read
#804   │ gicv3_dist_set_irq
#805   │ gicv3_dist_write
#806   │ gicv3_icc_ap_read
#807   │ gicv3_icc_ap_write
#808   │ gicv3_icc_bpr_read
#809   │ gicv3_icc_bpr_write
#810   │ gicv3_icc_ctlr_el3_read
#811   │ gicv3_icc_ctlr_el3_write
#812   │ gicv3_icc_ctlr_read
#813   │ gicv3_icc_ctlr_write
#814   │ gicv3_icc_dir_write
#815   │ gicv3_icc_eoir_write
#816   │ gicv3_icc_generate_sgi
#817   │ gicv3_icc_hppir0_read
#818   │ gicv3_icc_hppir1_read
#819   │ gicv3_icc_iar0_read
#820   │ gicv3_icc_iar1_read
#821   │ gicv3_icc_igrpen1_el3_read
#822   │ gicv3_icc_igrpen1_el3_write
#823   │ gicv3_icc_igrpen_read
#824   │ gicv3_icc_igrpen_write
#825   │ gicv3_icc_pmr_read
#826   │ gicv3_icc_pmr_write
#827   │ gicv3_icc_rpr_read
#828   │ gicv3_ich_ap_read
#829   │ gicv3_ich_ap_write
#830   │ gicv3_ich_eisr_read
#831   │ gicv3_ich_elrsr_read
#832   │ gicv3_ich_hcr_read
#833   │ gicv3_ich_hcr_write
#834   │ gicv3_ich_lr32_read
#835   │ gicv3_ich_lr32_write
#836   │ gicv3_ich_lr_read
#837   │ gicv3_ich_lr_write
#838   │ gicv3_ich_lrc_read
#839   │ gicv3_ich_lrc_write
#840   │ gicv3_ich_misr_read
#841   │ gicv3_ich_vmcr_read
#842   │ gicv3_ich_vmcr_write
#843   │ gicv3_ich_vtr_read
#844   │ gicv3_icv_ap_read
#845   │ gicv3_icv_ap_write
#846   │ gicv3_icv_bpr_read
#847   │ gicv3_icv_bpr_write
#848   │ gicv3_icv_ctlr_read
#849   │ gicv3_icv_ctlr_write
#850   │ gicv3_icv_dir_write
#851   │ gicv3_icv_eoir_write
#852   │ gicv3_icv_hppir_read
#853   │ gicv3_icv_iar_read
#854   │ gicv3_icv_igrpen_read
#855   │ gicv3_icv_igrpen_write
#856   │ gicv3_icv_pmr_read
#857   │ gicv3_icv_pmr_write
#858   │ gicv3_icv_rpr_read
#859   │ gicv3_its_badread
#860   │ gicv3_its_badwrite
#861   │ gicv3_its_cmd_clear
#862   │ gicv3_its_cmd_discard
#863   │ gicv3_its_cmd_int
#864   │ gicv3_its_cmd_inv
#865   │ gicv3_its_cmd_invall
#866   │ gicv3_its_cmd_mapc
#867   │ gicv3_its_cmd_mapd
#868   │ gicv3_its_cmd_mapi
#869   │ gicv3_its_cmd_mapti
#870   │ gicv3_its_cmd_movall
#871   │ gicv3_its_cmd_movi
#872   │ gicv3_its_cmd_sync
#873   │ gicv3_its_cmd_unknown
#874   │ gicv3_its_cmd_vinvall
#875   │ gicv3_its_cmd_vmapi
#876   │ gicv3_its_cmd_vmapp
#877   │ gicv3_its_cmd_vmapti
#878   │ gicv3_its_cmd_vmovi
#879   │ gicv3_its_cmd_vmovp
#880   │ gicv3_its_cmd_vsync
#881   │ gicv3_its_cte_read
#882   │ gicv3_its_cte_read_fault
#883   │ gicv3_its_cte_write
#884   │ gicv3_its_dte_read
#885   │ gicv3_its_dte_read_fault
#886   │ gicv3_its_dte_write
#887   │ gicv3_its_ite_read
#888   │ gicv3_its_ite_read_fault
#889   │ gicv3_its_ite_write
#890   │ gicv3_its_process_command
#891   │ gicv3_its_read
#892   │ gicv3_its_translation_write
#893   │ gicv3_its_vte_read
#894   │ gicv3_its_vte_read_fault
#895   │ gicv3_its_vte_write
#896   │ gicv3_its_write
#897   │ gicv3_redist_badread
#898   │ gicv3_redist_badwrite
#899   │ gicv3_redist_read
#900   │ gicv3_redist_send_sgi
#901   │ gicv3_redist_set_irq
#902   │ gicv3_redist_write

#979   │ i2c_ack
#980   │ i2c_event
#981   │ i2c_recv
#982   │ i2c_send
#983   │ i2c_send_async

#1313   │ memory_region_ops_read
#1314   │ memory_region_ops_write
#1315   │ memory_region_ram_device_read
#1316   │ memory_region_ram_device_write
#1317   │ memory_region_subpage_read
#1318   │ memory_region_subpage_write
#1319   │ memory_region_sync_dirty

#1988   │ pl011_baudrate_change
#1989   │ pl011_can_receive
#1990   │ pl011_irq_state
#1991   │ pl011_put_fifo
#1992   │ pl011_put_fifo_full
#1993   │ pl011_read
#1994   │ pl011_read_fifo
#1995   │ pl011_write

#3038   │ sdcard_app_command
#3039   │ sdcard_ejected
#3040   │ sdcard_erase
#3041   │ sdcard_inquiry_cmd41
#3042   │ sdcard_inserted
#3043   │ sdcard_lock
#3044   │ sdcard_normal_command
#3045   │ sdcard_powerup
#3046   │ sdcard_read_block
#3047   │ sdcard_read_data
#3048   │ sdcard_reset
#3049   │ sdcard_response
#3050   │ sdcard_set_blocklen
#3051   │ sdcard_set_voltage
#3052   │ sdcard_unlock
#3053   │ sdcard_write_block
#3054   │ sdcard_write_data

# Bunch of USB stuff from line 3497 till line 3812



#================
# Debug options.
#================

# For gdb connection:
# - if this is set, MUST have gdb attached for SYS_WRITE0 to work, otherwise QEMU will crash.
# - port 5555 is used to match the JLink configuration, so that we could reuse the same
#   GDB command for both QEMU and JTAG.
QEMU_GDB_OPTS = "-gdb tcp::5555 -S"

# GDB startup configuration.
GDB_CONNECT_FILE = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${TARGET}/gdb-connect"

#============
# Make Tasks
#============

[tasks.default]
alias = "all"

[tasks.all]
dependencies = ["kernel-binary"]

[tasks.modules]
command = "cargo"
args = ["modules", "tree"]

[tasks.do-build]
command = "cargo"
args = ["build", "@@split(PLATFORM_TARGET, )", "@@remove-empty(RUST_STD)", "@@remove-empty(RUST_STD_FEATURES)"]

[tasks.build]
disabled = true

[tasks.build-device]
env = { "TARGET_FEATURES" = "${TARGET_BOARD}" }
run_task = "do-build"

[tasks.build-qemu]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
run_task = "do-build"

[tasks.qemu-runner]
dependencies = ["build-qemu", "kernel-binary"]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
script = [
    "echo Run QEMU ${QEMU_OPTS} ${QEMU_RUNNER_OPTS} with ${KERNEL_BIN}",
    "rm -f qemu.log",
    "${QEMU} ${QEMU_OPTS} ${QEMU_RUNNER_OPTS} -dtb ${TARGET_DTB} -kernel ${KERNEL_BIN} 2>&1 | tee qemu.log"
]

[tasks.expand]
env = { "TARGET_FEATURES" = "" }
command = "cargo"
args = ["expand", "@@split(PLATFORM_TARGET, )"]

[tasks.test]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
command = "cargo"
args = ["test", "@@split(PLATFORM_TARGET, )", "@@remove-empty(RUST_STD)", "@@remove-empty(RUST_STD_FEATURES)"]

[tasks.docs]
env = { "TARGET_FEATURES" = "" }
command = "cargo"
args = ["doc", "--open", "--no-deps", "@@split(PLATFORM_TARGET, )"]

[tasks.clippy]
env = { "TARGET_FEATURES" = "rpi3", "CLIPPY_FEATURES" = { value = "--features=${CLIPPY_FEATURES}", condition = { env_set = ["CLIPPY_FEATURES"] } } }
command = "cargo"
args = ["clippy", "@@split(PLATFORM_TARGET, )", "@@remove-empty(CLIPPY_FEATURES)", "--", "--deny", "warnings", "--allow", "deprecated"]

# These tasks are written in cargo-make's own script to make it portable across platforms (no `basename` on Windows)

## Copy and prepare a given ELF file. Convert to binary output format.
[tasks.custom-binary]
env = { "BINARY_FILE" = "${BINARY_FILE}" }
script_runner = "@duckscript"
script = [
'''
    binaryFile = basename ${BINARY_FILE}
    outElf = set ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.elf
    outBin = set ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.bin
    cp ${BINARY_FILE} ${outElf}
    exec --fail-on-error ${OBJCOPY} %{OBJCOPY_PARAMS} ${BINARY_FILE} ${outBin}
    echo Copied ${binaryFile} to ${outElf}
    echo Converted ${binaryFile} to ${outBin}
'''
]
install_crate = { crate_name = "cargo-binutils", binary = "rust-objcopy", test_arg = ["--help"] }

## Copy and prepare binary with tests.
[tasks.test-binary]
env = { "BINARY_FILE" = "${CARGO_MAKE_TASK_ARGS}" }
run_task = "custom-binary"

## Run binary with tests in QEMU.
[tasks.test-runner]
dependencies = ["test-binary"]
script_runner = "@duckscript"
script = [
'''
    binaryFile = basename ${CARGO_MAKE_TASK_ARGS}
    echo Run QEMU %{QEMU_OPTS} %{QEMU_TESTS_OPTS} with target/${binaryFile}.bin
    exec --fail-on-error ${QEMU} %{QEMU_OPTS} %{QEMU_TESTS_OPTS} -dtb ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2710-rpi-3-b-plus.dtb -kernel ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.bin
'''
]

## Generate GDB startup configuration file.
[tasks.gdb-config]
script_runner = "@duckscript"
script = [
'''
    writefile ${GDB_CONNECT_FILE} "target extended-remote :5555\n"
    appendfile ${GDB_CONNECT_FILE} "break *0x80000\n"
    appendfile ${GDB_CONNECT_FILE} "break kernel_main\n"
    echo Generated GDB config file
'''
]
#appendfile ${GDB_CONNECT_FILE} "continue\n"

## Generate zellij configuration file.
[tasks.zellij-config]
dependencies = ["build-qemu", "kernel-binary"]
script_runner = "@duckscript"
env = { "ZELLIJ_CONFIG_FILE" = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/emulation/zellij-config.sh" }
script = [
'''
    writefile ${ZELLIJ_CONFIG_FILE} "QEMU=${QEMU}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "QEMU_OPTS=\"${QEMU_OPTS}\"\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "QEMU_RUNNER_OPTS=${QEMU_RUNNER_OPTS}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY=${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "TARGET_DTB=${TARGET_DTB}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "KERNEL_BIN=${KERNEL_BIN}\n"
'''
]
install_crate = { crate_name = "zellij", binary = "zellij", test_arg = ["--help"] }

[tasks.openocd]
script = [
    "${OPENOCD} -f interface/jlink.cfg -f ../ocd/${TARGET_BOARD}_target.cfg"
]

[tasks.sdeject]
dependencies = ["sdcard"]
script = [
    "diskutil unmount ${VOLUME}"
]

[tasks.chainboot]
dependencies = ["build-device", "kernel-binary"]
command = "echo"
args = ["\n***===***\n", "Run the following command in your terminal:\n", "  ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/debug/chainofcommand ${CHAINBOOT_SERIAL} ${CHAINBOOT_BAUD} --kernel ${KERNEL_BIN}\n", "***===***\n\n"]
