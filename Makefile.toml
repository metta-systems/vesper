#
# SPDX-License-Identifier: BlueOak-1.0.0
#
# Copyright (c) Berkus Decker <berkus+vesper@metta.systems>
#
[config]
min_version = "0.32.0"
default_to_workspace = true

[env]
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

DEFAULT_TARGET = "aarch64-vesper-metta"

#===================
# User-configurable
#===================

#-----------------------
# Target configuration.
#-----------------------

# Target triple.
# Pass TARGET env var if it does not match the default target above.
TARGET = { value = "${DEFAULT_TARGET}", condition = { env_not_set = ["TARGET"] } }

# Name of the target board.
# Currently supported: "rpi3" or "rpi4"
TARGET_BOARD = { value = "rpi4", condition = { env_not_set = ["TARGET_BOARD"] } }

# Name of the DTB file for target board configuration.
# Use bcm2710-rpi-3-b-plus.dtb for RasPi3B+.
TARGET_DTB = { value = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2711-rpi-4-b.dtb", condition = { env_not_set = ["TARGET_DTB"] } }

#------------------------
# Tooling configuration.
# (AArch64 targets for now)
#------------------------

# AArch64 QEMU binary
QEMU = { value = "qemu-system-aarch64", condition = { env_not_set = ["QEMU"] } }
# QEMU machine type, defaults to raspi3b but CI runners override it due to ancient QEMU versions they use.
QEMU_MACHINE = { value = "raspi3b", condition = { env_not_set = ["QEMU_MACHINE"] } }

# An aarch64-enabled GDB
GDB = { value = "/usr/local/opt/gdb/HEAD-a2c58332-aarch64/bin/aarch64-unknown-elf-gdb", condition = { env_not_set = ["GDB"] } }

# OpenOCD with JLink support
# (RTT patch from http://openocd.zylin.com/#/c/4055/11 has already been merged into main line)
OPENOCD = { value = "/usr/local/opt/openocd/4d6519593-rtt/bin/openocd", condition = { env_not_set = ["OPENOCD"] } }

# Path to a mounted sdcard partition to copy binaries to.
VOLUME = { value = "/Volumes/BOOT", condition = { env_not_set = ["VOLUME"] } }

#==================================
# Automatic.
# Nothing user-configurable below.
#==================================

RUST_STD = "-Zbuild-std=compiler_builtins,core,alloc"
RUST_STD_FEATURES = "-Zbuild-std-features=compiler-builtins-mem"

# Kernel binary paths.
KERNEL_ELF = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${TARGET}/release/nucleus"
KERNEL_BIN = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/nucleus.bin"

# Chain bootloader configuration.
CHAINBOOT_SERIAL = "/dev/tty.SLAB_USBtoUART"
CHAINBOOT_BAUD = 115200

#==========
# Commands
#==========

OBJCOPY = "rust-objcopy" # Part of `cargo objcopy` in cargo-binutils
OBJCOPY_PARAMS = "--strip-all -O binary"
NM = "rust-nm" # Part of `cargo nm` in cargo-binutils

# Containerised commands
UTILS_CONTAINER = "andrerichter/raspi3-utils"
DOCKER_CMD = "docker run -it --rm -v ${PWD}:/work -w /work -p 5900:5900"
QEMU_CONTAINER_CMD = "qemu-system-aarch64"

#================================================================
# Target settings
# Build requires "release" flag to properly optimize the binary.
#================================================================

TARGET_JSON = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/${TARGET}.json"
PLATFORM_TARGET="--release --target=${TARGET_JSON} --features=${TARGET_FEATURES}"

#=================
# Target features
#=================

DEVICE_FEATURES = "noserial"
QEMU_FEATURES = "qemu,rpi3" #,noserial"

#===================
# Emulation options
#===================
#
# Could additionally use -nographic to disable GUI -- this shall be useful for automated tests.
#
# QEMU has renamed the RasPi machines since version 6.2.0, use just `raspi3` for previous versions.
QEMU_OPTS = "-M ${QEMU_MACHINE} -semihosting"
QEMU_DISASM_OPTS = "-d unimp,int,mmu,cpu_reset,guest_errors" # --preconfig -singlestep
QEMU_SERIAL_OPTS = "" #-serial file:qemu.out -serial file:qemu.out2" #-serial pty -serial stdio"
QEMU_TESTS_OPTS = "-nographic" # -chardev file,id=char0,mux=on,path=debug.log -mon chardev=char0,mode=readline -semihosting-config chardev=char0" # -D error.log"
#Note that some other command line options may implicitly create multiplexed character backends;
#for instance -serial mon:stdio creates a multiplexed stdio backend connected to the serial port
#and the QEMU monitor, and -nographic also multiplexes the console and the monitor to stdio.


# Mon commands
# https://qemu-project.gitlab.io/qemu/system/monitor.html
#info qtree
#   Show device tree.

# For -d trace:
# E.g. -d trace:arm*,bcm2835_*,gic*,memory_*,pl011_*

# Also, try -d exec,nochain,out_asm for a full runtime dump?

#134   ‚îÇ arm_gt_cntvoff_write
#135   ‚îÇ arm_gt_ctl_write
#136   ‚îÇ arm_gt_cval_write
#137   ‚îÇ arm_gt_imask_toggle
#138   ‚îÇ arm_gt_recalc
#139   ‚îÇ arm_gt_recalc_disabled
#140   ‚îÇ arm_gt_tval_write
#141   ‚îÇ armsse_cpu_pwrctrl_read
#142   ‚îÇ armsse_cpu_pwrctrl_write
#143   ‚îÇ armsse_cpuid_read
#144   ‚îÇ armsse_cpuid_write
#145   ‚îÇ armsse_mhu_read
#146   ‚îÇ armsse_mhu_write

#224   ‚îÇ bcm2835_cprman_read
#225   ‚îÇ bcm2835_cprman_write
#226   ‚îÇ bcm2835_cprman_write_invalid_magic
#227   ‚îÇ bcm2835_ic_set_cpu_irq
#228   ‚îÇ bcm2835_ic_set_gpu_irq
#229   ‚îÇ bcm2835_mbox_irq
#230   ‚îÇ bcm2835_mbox_property
#231   ‚îÇ bcm2835_mbox_read
#232   ‚îÇ bcm2835_mbox_write
#233   ‚îÇ bcm2835_sdhost_edm_change
#234   ‚îÇ bcm2835_sdhost_read
#235   ‚îÇ bcm2835_sdhost_update_irq
#236   ‚îÇ bcm2835_sdhost_write
#237   ‚îÇ bcm2835_systmr_irq_ack
#238   ‚îÇ bcm2835_systmr_read
#239   ‚îÇ bcm2835_systmr_run
#240   ‚îÇ bcm2835_systmr_timer_expired
#241   ‚îÇ bcm2835_systmr_write

#782   ‚îÇ gic_acknowledge_irq
#783   ‚îÇ gic_cpu_read
#784   ‚îÇ gic_cpu_write
#785   ‚îÇ gic_disable_irq
#786   ‚îÇ gic_dist_read
#787   ‚îÇ gic_dist_write
#788   ‚îÇ gic_enable_irq
#789   ‚îÇ gic_hyp_read
#790   ‚îÇ gic_hyp_write
#791   ‚îÇ gic_lr_entry
#792   ‚îÇ gic_set_irq
#793   ‚îÇ gic_update_bestirq
#794   ‚îÇ gic_update_maintenance_irq
#795   ‚îÇ gic_update_set_irq

#796   ‚îÇ gicv3_cpuif_set_irqs
#797   ‚îÇ gicv3_cpuif_update
#798   ‚îÇ gicv3_cpuif_virt_set_irqs
#799   ‚îÇ gicv3_cpuif_virt_set_maint_irq
#800   ‚îÇ gicv3_cpuif_virt_update
#801   ‚îÇ gicv3_dist_badread
#802   ‚îÇ gicv3_dist_badwrite
#803   ‚îÇ gicv3_dist_read
#804   ‚îÇ gicv3_dist_set_irq
#805   ‚îÇ gicv3_dist_write
#806   ‚îÇ gicv3_icc_ap_read
#807   ‚îÇ gicv3_icc_ap_write
#808   ‚îÇ gicv3_icc_bpr_read
#809   ‚îÇ gicv3_icc_bpr_write
#810   ‚îÇ gicv3_icc_ctlr_el3_read
#811   ‚îÇ gicv3_icc_ctlr_el3_write
#812   ‚îÇ gicv3_icc_ctlr_read
#813   ‚îÇ gicv3_icc_ctlr_write
#814   ‚îÇ gicv3_icc_dir_write
#815   ‚îÇ gicv3_icc_eoir_write
#816   ‚îÇ gicv3_icc_generate_sgi
#817   ‚îÇ gicv3_icc_hppir0_read
#818   ‚îÇ gicv3_icc_hppir1_read
#819   ‚îÇ gicv3_icc_iar0_read
#820   ‚îÇ gicv3_icc_iar1_read
#821   ‚îÇ gicv3_icc_igrpen1_el3_read
#822   ‚îÇ gicv3_icc_igrpen1_el3_write
#823   ‚îÇ gicv3_icc_igrpen_read
#824   ‚îÇ gicv3_icc_igrpen_write
#825   ‚îÇ gicv3_icc_pmr_read
#826   ‚îÇ gicv3_icc_pmr_write
#827   ‚îÇ gicv3_icc_rpr_read
#828   ‚îÇ gicv3_ich_ap_read
#829   ‚îÇ gicv3_ich_ap_write
#830   ‚îÇ gicv3_ich_eisr_read
#831   ‚îÇ gicv3_ich_elrsr_read
#832   ‚îÇ gicv3_ich_hcr_read
#833   ‚îÇ gicv3_ich_hcr_write
#834   ‚îÇ gicv3_ich_lr32_read
#835   ‚îÇ gicv3_ich_lr32_write
#836   ‚îÇ gicv3_ich_lr_read
#837   ‚îÇ gicv3_ich_lr_write
#838   ‚îÇ gicv3_ich_lrc_read
#839   ‚îÇ gicv3_ich_lrc_write
#840   ‚îÇ gicv3_ich_misr_read
#841   ‚îÇ gicv3_ich_vmcr_read
#842   ‚îÇ gicv3_ich_vmcr_write
#843   ‚îÇ gicv3_ich_vtr_read
#844   ‚îÇ gicv3_icv_ap_read
#845   ‚îÇ gicv3_icv_ap_write
#846   ‚îÇ gicv3_icv_bpr_read
#847   ‚îÇ gicv3_icv_bpr_write
#848   ‚îÇ gicv3_icv_ctlr_read
#849   ‚îÇ gicv3_icv_ctlr_write
#850   ‚îÇ gicv3_icv_dir_write
#851   ‚îÇ gicv3_icv_eoir_write
#852   ‚îÇ gicv3_icv_hppir_read
#853   ‚îÇ gicv3_icv_iar_read
#854   ‚îÇ gicv3_icv_igrpen_read
#855   ‚îÇ gicv3_icv_igrpen_write
#856   ‚îÇ gicv3_icv_pmr_read
#857   ‚îÇ gicv3_icv_pmr_write
#858   ‚îÇ gicv3_icv_rpr_read
#859   ‚îÇ gicv3_its_badread
#860   ‚îÇ gicv3_its_badwrite
#861   ‚îÇ gicv3_its_cmd_clear
#862   ‚îÇ gicv3_its_cmd_discard
#863   ‚îÇ gicv3_its_cmd_int
#864   ‚îÇ gicv3_its_cmd_inv
#865   ‚îÇ gicv3_its_cmd_invall
#866   ‚îÇ gicv3_its_cmd_mapc
#867   ‚îÇ gicv3_its_cmd_mapd
#868   ‚îÇ gicv3_its_cmd_mapi
#869   ‚îÇ gicv3_its_cmd_mapti
#870   ‚îÇ gicv3_its_cmd_movall
#871   ‚îÇ gicv3_its_cmd_movi
#872   ‚îÇ gicv3_its_cmd_sync
#873   ‚îÇ gicv3_its_cmd_unknown
#874   ‚îÇ gicv3_its_cmd_vinvall
#875   ‚îÇ gicv3_its_cmd_vmapi
#876   ‚îÇ gicv3_its_cmd_vmapp
#877   ‚îÇ gicv3_its_cmd_vmapti
#878   ‚îÇ gicv3_its_cmd_vmovi
#879   ‚îÇ gicv3_its_cmd_vmovp
#880   ‚îÇ gicv3_its_cmd_vsync
#881   ‚îÇ gicv3_its_cte_read
#882   ‚îÇ gicv3_its_cte_read_fault
#883   ‚îÇ gicv3_its_cte_write
#884   ‚îÇ gicv3_its_dte_read
#885   ‚îÇ gicv3_its_dte_read_fault
#886   ‚îÇ gicv3_its_dte_write
#887   ‚îÇ gicv3_its_ite_read
#888   ‚îÇ gicv3_its_ite_read_fault
#889   ‚îÇ gicv3_its_ite_write
#890   ‚îÇ gicv3_its_process_command
#891   ‚îÇ gicv3_its_read
#892   ‚îÇ gicv3_its_translation_write
#893   ‚îÇ gicv3_its_vte_read
#894   ‚îÇ gicv3_its_vte_read_fault
#895   ‚îÇ gicv3_its_vte_write
#896   ‚îÇ gicv3_its_write
#897   ‚îÇ gicv3_redist_badread
#898   ‚îÇ gicv3_redist_badwrite
#899   ‚îÇ gicv3_redist_read
#900   ‚îÇ gicv3_redist_send_sgi
#901   ‚îÇ gicv3_redist_set_irq
#902   ‚îÇ gicv3_redist_write

#979   ‚îÇ i2c_ack
#980   ‚îÇ i2c_event
#981   ‚îÇ i2c_recv
#982   ‚îÇ i2c_send
#983   ‚îÇ i2c_send_async

#1313   ‚îÇ memory_region_ops_read
#1314   ‚îÇ memory_region_ops_write
#1315   ‚îÇ memory_region_ram_device_read
#1316   ‚îÇ memory_region_ram_device_write
#1317   ‚îÇ memory_region_subpage_read
#1318   ‚îÇ memory_region_subpage_write
#1319   ‚îÇ memory_region_sync_dirty

#1988   ‚îÇ pl011_baudrate_change
#1989   ‚îÇ pl011_can_receive
#1990   ‚îÇ pl011_irq_state
#1991   ‚îÇ pl011_put_fifo
#1992   ‚îÇ pl011_put_fifo_full
#1993   ‚îÇ pl011_read
#1994   ‚îÇ pl011_read_fifo
#1995   ‚îÇ pl011_write

#3038   ‚îÇ sdcard_app_command
#3039   ‚îÇ sdcard_ejected
#3040   ‚îÇ sdcard_erase
#3041   ‚îÇ sdcard_inquiry_cmd41
#3042   ‚îÇ sdcard_inserted
#3043   ‚îÇ sdcard_lock
#3044   ‚îÇ sdcard_normal_command
#3045   ‚îÇ sdcard_powerup
#3046   ‚îÇ sdcard_read_block
#3047   ‚îÇ sdcard_read_data
#3048   ‚îÇ sdcard_reset
#3049   ‚îÇ sdcard_response
#3050   ‚îÇ sdcard_set_blocklen
#3051   ‚îÇ sdcard_set_voltage
#3052   ‚îÇ sdcard_unlock
#3053   ‚îÇ sdcard_write_block
#3054   ‚îÇ sdcard_write_data

# Bunch of USB stuff from line 3497 till line 3812



#================
# Debug options.
#================

# For gdb connection:
# - if this is set, MUST have gdb attached for SYS_WRITE0 to work, otherwise QEMU will crash.
# - port 5555 is used to match the JLink configuration, so that we could reuse the same
#   GDB command for both QEMU and JTAG.
QEMU_GDB_OPTS = "-gdb tcp::5555 -S"

# GDB startup configuration.
GDB_CONNECT_FILE = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${TARGET}/gdb-connect"

#============
# Make Tasks
#============

[tasks.default]
alias = "all"

[tasks.all]
dependencies = ["kernel-binary"]

[tasks.modules]
command = "cargo"
args = ["modules", "tree"]

[tasks.do-build]
command = "cargo"
args = ["build", "@@split(PLATFORM_TARGET, )", "@@remove-empty(RUST_STD)", "@@remove-empty(RUST_STD_FEATURES)"]

[tasks.build]
disabled = true

[tasks.build-device]
env = { "TARGET_FEATURES" = "${TARGET_BOARD}" }
run_task = "do-build"

[tasks.build-qemu]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
run_task = "do-build"

[tasks.qemu-runner]
dependencies = ["build-qemu", "kernel-binary"]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
script = [
    "echo üöú Run QEMU ${QEMU_OPTS} ${QEMU_RUNNER_OPTS} with ${KERNEL_BIN}",
    "rm -f qemu.log",
    "${QEMU} ${QEMU_OPTS} ${QEMU_RUNNER_OPTS} -dtb ${TARGET_DTB} -kernel ${KERNEL_BIN} 2>&1 | tee qemu.log"
]

[tasks.expand]
env = { "TARGET_FEATURES" = "" }
command = "cargo"
args = ["expand", "@@split(PLATFORM_TARGET, )"]

[tasks.test]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
command = "cargo"
args = ["test", "@@split(PLATFORM_TARGET, )", "@@remove-empty(RUST_STD)", "@@remove-empty(RUST_STD_FEATURES)"]

[tasks.docs]
env = { "TARGET_FEATURES" = "" }
command = "cargo"
args = ["doc", "--open", "--no-deps", "@@split(PLATFORM_TARGET, )"]

[tasks.clippy]
env = { "TARGET_FEATURES" = "rpi3", "CLIPPY_FEATURES" = { value = "--features=${CLIPPY_FEATURES}", condition = { env_set = ["CLIPPY_FEATURES"] } } }
command = "cargo"
args = ["clippy", "@@split(PLATFORM_TARGET, )", "@@remove-empty(CLIPPY_FEATURES)", "--", "--deny", "warnings", "--allow", "deprecated"]

# These tasks are written in cargo-make's own script to make it portable across platforms (no `basename` on Windows)

## Copy and prepare a given ELF file. Convert to binary output format.
[tasks.custom-binary]
env = { "BINARY_FILE" = "${BINARY_FILE}" }
script_runner = "@duckscript"
script = [
'''
    binaryFile = basename ${BINARY_FILE}
    outElf = set ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.elf
    outBin = set ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.bin
    cp ${BINARY_FILE} ${outElf}
    exec --fail-on-error ${OBJCOPY} %{OBJCOPY_PARAMS} ${BINARY_FILE} ${outBin}
    echo üîÑ Copied ${binaryFile} to ${outElf}
    echo üí´ Converted ${binaryFile} to ${outBin}
'''
]
install_crate = { crate_name = "cargo-binutils", binary = "rust-objcopy", test_arg = ["--help"] }

## Copy and prepare binary with tests.
[tasks.test-binary]
env = { "BINARY_FILE" = "${CARGO_MAKE_TASK_ARGS}" }
run_task = "custom-binary"

## Run binary with tests in QEMU.
[tasks.test-runner]
dependencies = ["test-binary"]
script_runner = "@duckscript"
script = [
'''
    binaryFile = basename ${CARGO_MAKE_TASK_ARGS}
    echo üèéÔ∏è Run QEMU %{QEMU_OPTS} %{QEMU_TESTS_OPTS} with target/${binaryFile}.bin
    exec --fail-on-error ${QEMU} %{QEMU_OPTS} %{QEMU_TESTS_OPTS} -dtb ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2710-rpi-3-b-plus.dtb -kernel ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.bin
'''
]

## Generate GDB startup configuration file.
[tasks.gdb-config]
script_runner = "@duckscript"
script = [
'''
    writefile ${GDB_CONNECT_FILE} "target extended-remote :5555\n"
    appendfile ${GDB_CONNECT_FILE} "break *0x80000\n"
    appendfile ${GDB_CONNECT_FILE} "break kernel_main\n"
    echo üñåÔ∏è Generated GDB config file
'''
]
#appendfile ${GDB_CONNECT_FILE} "continue\n"

## Generate zellij configuration file.
[tasks.zellij-config]
dependencies = ["build-qemu", "kernel-binary"]
script_runner = "@duckscript"
env = { "ZELLIJ_CONFIG_FILE" = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/emulation/zellij-config.sh" }
script = [
'''
    writefile ${ZELLIJ_CONFIG_FILE} "QEMU=${QEMU}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "QEMU_OPTS=\"${QEMU_OPTS}\"\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "QEMU_RUNNER_OPTS=${QEMU_RUNNER_OPTS}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY=${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "TARGET_DTB=${TARGET_DTB}\n"
    appendfile ${ZELLIJ_CONFIG_FILE} "KERNEL_BIN=${KERNEL_BIN}\n"
'''
]
install_crate = { crate_name = "zellij", binary = "zellij", test_arg = ["--help"] }

[tasks.openocd]
script = [
    "${OPENOCD} -f interface/jlink.cfg -f ../ocd/${TARGET_BOARD}_target.cfg"
]

[tasks.sdeject]
dependencies = ["sdcard"]
script = [
    "diskutil unmount ${VOLUME}"
]

[tasks.chainboot]
dependencies = ["build-device", "kernel-binary"]
command = "echo"
args = ["\n***===***\n", "üèéÔ∏è Run the following command in your terminal:\n", "üèéÔ∏è   ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/debug/chainofcommand ${CHAINBOOT_SERIAL} ${CHAINBOOT_BAUD} --kernel ${KERNEL_BIN}\n", "***===***\n\n"]
