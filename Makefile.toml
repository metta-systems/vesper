#
# SPDX-License-Identifier: BlueOak-1.0.0
#
# Copyright (c) Berkus Decker <berkus+vesper@metta.systems>
#
[config]
min_version = "0.32.0"
default_to_workspace = true

[env]
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

DEFAULT_TARGET = "aarch64-vesper-metta"

#===================
# User-configurable
#===================

#-----------------------
# Target configuration.
#-----------------------

# Target triple.
# Pass TARGET env var if it does not match the default target above.
TARGET = { value = "${DEFAULT_TARGET}", condition = { env_not_set = ["TARGET"] } }

# Name of the target board.
# Currently supported: "rpi3" or "rpi4"
TARGET_BOARD = { value = "rpi4", condition = { env_not_set = ["TARGET_BOARD"] } }

# Name of the DTB file for target board configuration.
# Use bcm2710-rpi-3-b-plus.dtb for RasPi3B+.
TARGET_DTB = { value = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2711-rpi-4-b.dtb", condition = { env_not_set = ["TARGET_DTB"] } }

#------------------------
# Tooling configuration.
# (AArch64 targets for now)
#------------------------

# AArch64 QEMU binary
QEMU = { value = "qemu-system-aarch64", condition = { env_not_set = ["QEMU"] } }
# QEMU machine type, defaults to raspi3b but CI runners override it due to ancient QEMU versions they use.
QEMU_MACHINE = { value = "raspi3b", condition = { env_not_set = ["QEMU_MACHINE"] } }

# An aarch64-enabled GDB
GDB = { value = "/usr/local/opt/gdb/HEAD-a2c58332-aarch64/bin/aarch64-unknown-elf-gdb", condition = { env_not_set = ["GDB"] } }

# OpenOCD with JLink support
# (RTT patch from http://openocd.zylin.com/#/c/4055/11 has already been merged into main line)
OPENOCD = { value = "/usr/local/opt/openocd/4d6519593-rtt/bin/openocd", condition = { env_not_set = ["OPENOCD"] } }

#==================================
# Automatic.
# Nothing user-configurable below.
#==================================

RUST_STD = "-Zbuild-std=compiler_builtins,core,alloc"
RUST_STD_FEATURES = "-Zbuild-std-features=compiler-builtins-mem"

# Kernel binary paths.
KERNEL_ELF = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${TARGET}/release/nucleus"
KERNEL_BIN = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/nucleus.bin"

#==========
# Commands
#==========

OBJCOPY = "rust-objcopy" # Part of `cargo objcopy` in cargo-binutils
OBJCOPY_PARAMS = "--strip-all -O binary"
NM = "rust-nm" # Part of `cargo nm` in cargo-binutils

# Containerised commands
UTILS_CONTAINER = "andrerichter/raspi3-utils"
DOCKER_CMD = "docker run -it --rm -v ${PWD}:/work -w /work -p 5900:5900"
QEMU_CONTAINER_CMD = "qemu-system-aarch64"

#================================================================
# Target settings
# Build requires "release" flag to properly optimize the binary.
#================================================================

TARGET_JSON = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/${TARGET}.json"
PLATFORM_TARGET="--release --target=${TARGET_JSON} --features=${TARGET_FEATURES}"

#=================
# Target features
#=================

QEMU_FEATURES = "qemu"

#===================
# Emulation options
#===================
#
# Could additionally use -nographic to disable GUI -- this shall be useful for automated tests.
#
# QEMU has renamed the RasPi machines since version 6.2.0, use just `raspi3` for previous versions.
QEMU_OPTS = "-M ${QEMU_MACHINE} -semihosting"
QEMU_DISASM_OPTS = "-d unimp,int,mmu,cpu_reset,guest_errors"
QEMU_SERIAL_OPTS = ""
QEMU_TESTS_OPTS = "-nographic"

#================
# Debug options.
#================

# For gdb connection:
# - if this is set, MUST have gdb attached for SYS_WRITE0 to work, otherwise QEMU will crash.
# - port 5555 is used to match the JLink configuration, so that we could reuse the same
#   GDB command for both QEMU and JTAG.
QEMU_GDB_OPTS = "-gdb tcp::5555 -S"

# GDB startup configuration.
GDB_CONNECT_FILE = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${TARGET}/gdb-connect"

#============
# Make Tasks
#============

[tasks.default]
alias = "all"

[tasks.all]
dependencies = ["kernel-binary"]

[tasks.do-build]
command = "cargo"
args = ["build", "@@split(PLATFORM_TARGET, )", "@@remove-empty(RUST_STD)", "@@remove-empty(RUST_STD_FEATURES)"]

[tasks.build]
disabled = true

[tasks.build-qemu]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
run_task = "do-build"

[tasks.qemu-runner]
dependencies = ["build-qemu", "kernel-binary"]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
script = [
    "echo üöú Run QEMU ${QEMU_OPTS} ${QEMU_RUNNER_OPTS} with ${KERNEL_BIN}\n\n\n",
    "rm -f qemu.log",
    "${QEMU} ${QEMU_OPTS} ${QEMU_RUNNER_OPTS} -dtb ${TARGET_DTB} -kernel ${KERNEL_BIN} 2>&1 | tee qemu.log",
    "echo \n\n"
]

[tasks.test]
env = { "TARGET_FEATURES" = "${QEMU_FEATURES}" }
command = "cargo"
args = ["test", "@@split(PLATFORM_TARGET, )", "@@remove-empty(RUST_STD)", "@@remove-empty(RUST_STD_FEATURES)"]

# These tasks are written in cargo-make's own script to make it portable across platforms (no `basename` on Windows)

## Copy and prepare a given ELF file. Convert to binary output format.
[tasks.custom-binary]
env = { "BINARY_FILE" = "${BINARY_FILE}" }
script_runner = "@duckscript"
script = [
'''
    binaryFile = basename ${BINARY_FILE}
    outElf = set ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.elf
    outBin = set ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.bin
    cp ${BINARY_FILE} ${outElf}
    exec --fail-on-error ${OBJCOPY} %{OBJCOPY_PARAMS} ${BINARY_FILE} ${outBin}
    echo üîÑ Copied ${binaryFile} to ${outElf}
    echo üí´ Converted ${binaryFile} to ${outBin}
'''
]
install_crate = { crate_name = "cargo-binutils", binary = "rust-objcopy", test_arg = ["--help"] }

## Copy and prepare binary with tests.
[tasks.test-binary]
env = { "BINARY_FILE" = "${CARGO_MAKE_TASK_ARGS}" }
run_task = "custom-binary"

## Run binary with tests in QEMU.
[tasks.test-runner]
dependencies = ["test-binary"]
script_runner = "@duckscript"
script = [
'''
    binaryFile = basename ${CARGO_MAKE_TASK_ARGS}
    echo üèéÔ∏è Run QEMU %{QEMU_OPTS} %{QEMU_TESTS_OPTS} with target/${binaryFile}.bin
    exec --fail-on-error ${QEMU} %{QEMU_OPTS} %{QEMU_TESTS_OPTS} -dtb ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2710-rpi-3-b-plus.dtb -kernel ${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/target/${binaryFile}.bin
'''
]

## Generate GDB startup configuration file.
[tasks.gdb-config]
script_runner = "@duckscript"
script = [
'''
    writefile ${GDB_CONNECT_FILE} "target extended-remote :5555\n"
    appendfile ${GDB_CONNECT_FILE} "break *0x80000\n"
    appendfile ${GDB_CONNECT_FILE} "break kernel_main\n"
    echo üñåÔ∏è Generated GDB config file
'''
]


[tasks.kernel-binary]
env = { "BINARY_FILE" = "${KERNEL_ELF}" }
run_task = "custom-binary"

[tasks.qemu]
env = { "QEMU_RUNNER_OPTS" = "${QEMU_SERIAL_OPTS}", "TARGET_DTB" = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2710-rpi-3-b-plus.dtb" }
extend = "qemu-runner"

[tasks.qemu-gdb]
env = { "QEMU_RUNNER_OPTS" = "${QEMU_SERIAL_OPTS} ${QEMU_GDB_OPTS}", "TARGET_DTB" = "${CARGO_MAKE_WORKSPACE_WORKING_DIRECTORY}/targets/bcm2710-rpi-3-b-plus.dtb" }
extend = "qemu-runner"

[tasks.gdb]
dependencies = ["build", "kernel-binary", "gdb-config"]
env = { "RUST_GDB" = "${GDB}" }
script = [
    "exec < /dev/tty && pipx run gdbgui -g \"rust-gdb -x ${GDB_CONNECT_FILE} ${KERNEL_ELF}\""
]
